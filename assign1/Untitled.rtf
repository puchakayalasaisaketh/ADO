{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red253\green143\blue63;\red31\green31\blue36;\red252\green106\blue93;
\red255\green255\blue255;\red252\green95\blue163;\red65\green161\blue192;\red108\green121\blue134;\red208\green191\blue105;
}
{\*\expandedcolortbl;;\csgenericrgb\c99131\c56076\c24611;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c98912\c41558\c36568;
\csgenericrgb\c100000\c100000\c100000\c85000;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c25490\c63137\c75294;\csgenericrgb\c42394\c47462\c52518;\csgenericrgb\c81498\c74939\c41233;
}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\partightenfactor0

\f0\fs24 \cf2 \cb3 #include\cf4 <stdio.h>\cf5 \
\cf2 #include\cf4 <stdlib.h>\cf5 \
\cf2 #include\cf4 <sys/stat.h>\cf5 \
\cf2 #include\cf4 <sys/types.h>\cf5 \
\cf2 #include\cf4 <unistd.h>\cf5 \
\cf2 #include\cf4 <string.h>\cf5 \
\cf2 #include\cf4 <math.h>\cf5 \
\
\cf2 #include \cf4 "storage_mgr.h"\cf5 \
\
FILE *fileStream = 
\f1\b \cf6 NULL
\f0\b0 \cf5 ;\
\

\f1\b \cf6 extern
\f0\b0 \cf5  
\f1\b \cf6 void
\f0\b0 \cf5  \cf7 initStorageManager\cf5  (
\f1\b \cf6 void
\f0\b0 \cf5 ) \{\
	\cf8 // Initialising file pointer i.e. fileStream is set to be null.\cf5 \
	fileStream = 
\f1\b \cf6 NULL
\f0\b0 \cf5 ;\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 createPageFile\cf5 (
\f1\b \cf6 char
\f0\b0 \cf5  *fileName) \{\
    FILE *fileStream = fopen(fileName, \cf4 "w+"\cf5 ); \cf8 // access mode is set to read and write i.e, "w+")\cf5 \
\
    
\f1\b \cf6 if
\f0\b0 \cf5  (fileStream == 
\f1\b \cf6 NULL
\f0\b0 \cf5 ) \{\
        \cf8 // returning rc_file_not_found if file was not opened\cf5 \
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_NOT_FOUND;\
    \}\
\
    \cf8 // Creating an empty page in memory by allocating memory for it.\cf5 \
    SM_PageHandle emptyPageBuffer = (SM_PageHandle)malloc(PAGE_SIZE);\
\
    
\f1\b \cf6 if
\f0\b0 \cf5  (emptyPageBuffer == 
\f1\b \cf6 NULL
\f0\b0 \cf5 ) \{\
        \cf8 // Handle memory allocation failure.\cf5 \
        fclose(fileStream); \cf8 // Close the file before returning.\cf5 \
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_MALLOC_FAILED;\
    \}\
\
    \cf8 // Initialize the empty page to zero.\cf5 \
    memset(emptyPageBuffer, \cf9 0\cf5 , PAGE_SIZE);\
\
    \
    size_t writeResult = fwrite(emptyPageBuffer, 
\f1\b \cf6 sizeof
\f0\b0 \cf5 (
\f1\b \cf6 char
\f0\b0 \cf5 ), PAGE_SIZE, fileStream) ;\
	\cf8 // Write the empty page to the file.\cf5 \
\
    
\f1\b \cf6 if
\f0\b0 \cf5  ( writeResult< PAGE_SIZE) \{\
        printf(\cf4 "Write failed\\n"\cf5 ); \cf8 //print an error message if write operation is failed\cf5 \
        free(emptyPageBuffer); \cf8 // Free allocated memory.\cf5 \
        fclose(fileStream); \cf8 // Close the file.\cf5 \
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_WRITE_FAILED;\
    \} 
\f1\b \cf6 else
\f0\b0 \cf5  \{\
        printf(\cf4 "Write succeeded\\n"\cf5 );  \cf8 //prints success message \cf5 \
    \}\
\
    \cf8 // Close the fileStream to make sure all the buffers are removed .\cf5 \
    fclose(fileStream);\
    free(emptyPageBuffer);  \cf8 //deallocating the memory previously assigned to emptyPageBuffer\cf5 \
\
    
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK; \cf8 //this indicates file is successfully created\cf5 \
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 openPageFile\cf5 (
\f1\b \cf6 char
\f0\b0 \cf5  *fileName, SM_FileHandle *fHandle) \{\
    \cf8 // Attempt to open the file in read mode.\cf5 \
    fileStream = fopen(fileName, \cf4 "r"\cf5 );\
\
    \cf8 // Check if the file was not successfully opened.\cf5 \
    
\f1\b \cf6 if
\f0\b0 \cf5  (fileStream == 
\f1\b \cf6 NULL
\f0\b0 \cf5 ) \{\
        fclose(fileStream); \cf8 // Close the file handle.\cf5 \
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_NOT_FOUND; \cf8 // Return error: File not found.\cf5 \
    \}\
\
    \cf8 // Initialize the file handle values.\cf5 \
    fHandle->fileName = fileName; \cf8 // Set the file name.\cf5 \
    fHandle->curPagePos = \cf9 0\cf5 ; \cf8 // Set the current page position.\cf5 \
\
    \cf8 // Retrieve file information using fstat.\cf5 \
    
\f1\b \cf6 struct
\f0\b0 \cf5  stat fileInfo;\
    
\f1\b \cf6 if
\f0\b0 \cf5  (fstat(fileno(fileStream), &fileInfo) < \cf9 0\cf5 ) \{\
        fclose(fileStream); \cf8 // Close the file handle.\cf5 \
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_ERROR; \cf8 // Return error: Unable to obtain file information.\cf5 \
    \}\
\
    \cf8 // Calculate the total number of pages based on file size and page size.\cf5 \
    fHandle->totalNumPages = fileInfo.st_size / PAGE_SIZE;\
\
    \cf8 // Close the file to flush any internal buffers and release resources.\cf5 \
    fclose(fileStream);\
    
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK; \cf8 // Return success.\cf5 \
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 closePageFile\cf5  (SM_FileHandle *fHandle) \{\
	\cf8 // checking if fileStream is null or not.\cf5 \
	
\f1\b \cf6 if
\f0\b0 \cf5 (fileStream != 
\f1\b \cf6 NULL
\f0\b0 \cf5 )\{\
		\cf8 //assign the fhandle pointer to null to indicate it is closed.\cf5 \
		fHandle->mgmtInfo =
\f1\b \cf6 NULL
\f0\b0 \cf5 ; \cf8 //mgmtInfo field is more modular and safer approcah because it does not rely on a global variable\cf5 \
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK;\
	\}\
	
\f1\b \cf6 else
\f0\b0 \cf5 \{\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_HANDLE_NOT_INIT;\
	\}\
\}\
\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 destroyPageFile\cf5  (
\f1\b \cf6 char
\f0\b0 \cf5  *fileName) \{\
	\cf8 // Opening in read mode!	\cf5 \
	fileStream = fopen(fileName, \cf4 "r"\cf5 );\
	\
	
\f1\b \cf6 if
\f0\b0 \cf5 (fileStream == 
\f1\b \cf6 NULL
\f0\b0 \cf5 )\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_NOT_FOUND; \
	\
	\cf8 //closing the file stream\cf5 \
	fclose(fileStream);\
	\cf8 //Remove the file from file System\cf5 \
	\cf8 //remove(fileName);\cf5 \
	
\f1\b \cf6 if
\f0\b0 \cf5  (remove(fileName)==\cf9 0\cf5 )\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK;\
	
\f1\b \cf6 else
\f0\b0 \cf5 \
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_DELETE_FAILED;\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 readBlock\cf5 (
\f1\b \cf6 int
\f0\b0 \cf5  pageNum, SM_FileHandle *fHandle, SM_PageHandle memPage) \{\
    \cf8 // Checking if the pageNumber parameter is out of bounds\cf5 \
    
\f1\b \cf6 if
\f0\b0 \cf5  (pageNum < \cf9 0\cf5  || pageNum >= fHandle->totalNumPages) \{\
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_READ_NON_EXISTING_PAGE; \cf8 // Return error code for non-existing page\cf5 \
    \}\
\
    \cf8 // Opening the file stream in read mode ('r' mode creates an empty file for reading only)\cf5 \
    FILE *fileStream = fopen(fHandle->fileName, \cf4 "r"\cf5 );\
\
    \cf8 // Checking if file was successfully opened\cf5 \
    
\f1\b \cf6 if
\f0\b0 \cf5  (fileStream == 
\f1\b \cf6 NULL
\f0\b0 \cf5 ) \{\
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_NOT_FOUND; \cf8 // Return error code for file not found\cf5 \
    \}\
\
    \cf8 // Setting the cursor (pointer) position of the file stream.\cf5 \
    \cf8 // Position is calculated by Page Number x Page Size.\cf5 \
    \cf8 // The seek is successful if fseek() returns 0.\cf5 \
    
\f1\b \cf6 if
\f0\b0 \cf5  (fseek(fileStream, pageNum * PAGE_SIZE, SEEK_SET) != \cf9 0\cf5 ) \{\
        fclose(fileStream);\
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_READ_NON_EXISTING_PAGE; \cf8 // Return error code for non-existing page\cf5 \
    \}\
\
    \cf8 // We're reading the content and storing it in the location pointed out by memPage.\cf5 \
    fread(memPage, 
\f1\b \cf6 sizeof
\f0\b0 \cf5 (
\f1\b \cf6 char
\f0\b0 \cf5 ), PAGE_SIZE, fileStream);\
\
    \cf8 // Setting the current page position to the cursor (pointer) position of the file stream.\cf5 \
    fHandle->curPagePos = ftell(fileStream);\
\
    \cf8 // Closing the file stream so that all the buffers are flushed.\cf5 \
    fclose(fileStream);\
\
    
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK; \cf8 // Return success code\cf5 \
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  
\f1\b \cf6 int
\f0\b0 \cf5  \cf7 getBlockPos\cf5  (SM_FileHandle *fHandle) \{\
	\cf8 // Returning the current page position retrieved from the file handle	\cf5 \
	
\f1\b \cf6 return
\f0\b0 \cf5  fHandle->curPagePos;\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 readFirstBlock\cf5  (SM_FileHandle *fHandle, SM_PageHandle memPage) \{\
	\cf8 // Re-directing (passing) to readBlock(...) function with pageNumber = 0 i.e. first block	\cf5 \
	
\f1\b \cf6 return
\f0\b0 \cf5  readBlock(\cf9 0\cf5 , fHandle, memPage);\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 readPreviousBlock\cf5  (SM_FileHandle *fHandle, SM_PageHandle memPage) \{\
	\cf8 //printf("CURRENT PAGE POSITION = %d \\n", fHandle->curPagePos);\cf5 \
	\cf8 //printf("TOTAL PAGES = %d \\n", fHandle->totalNumPages);\cf5 \
\
	\cf8 // Calculating current page number by dividing page size by current page position	\cf5 \
	
\f1\b \cf6 int
\f0\b0 \cf5  currPageNumber = fHandle->curPagePos / PAGE_SIZE;\
\
	\cf8 // Re-directing (passing) to readBlock(...) function with pageNumber = currentPagePosition - 1 i.e. previous block\cf5 \
	
\f1\b \cf6 return
\f0\b0 \cf5  readBlock(currPageNumber - \cf9 1\cf5 , fHandle, memPage);\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 readCurrentBlock\cf5  (SM_FileHandle *fHandle, SM_PageHandle memPage) \{\
	\cf8 // Calculating current page number by dividing page size by current page position	\cf5 \
	
\f1\b \cf6 int
\f0\b0 \cf5  currPageNumber = fHandle->curPagePos / PAGE_SIZE;\
	\
	\cf8 // Re-directing (passing) to readBlock(...) function with pageNumber = currentPagePosition i.e. current block\cf5 \
	
\f1\b \cf6 return
\f0\b0 \cf5  readBlock(currPageNumber, fHandle, memPage);\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 readNextBlock\cf5  (SM_FileHandle *fHandle, SM_PageHandle memPage)\{\
	\cf8 // Calculating current page number by dividing page size by current page position	\cf5 \
	
\f1\b \cf6 int
\f0\b0 \cf5  currPageNumber = fHandle->curPagePos / PAGE_SIZE;\
	\
	printf(\cf4 "CURRENT PAGE POSITION = %d \\n"\cf5 , fHandle->curPagePos);\
	\cf8 // Re-directing (passing) to readBlock(...) function with pageNumber = currentPagePosition + 1 i.e. last block\cf5 \
	
\f1\b \cf6 return
\f0\b0 \cf5  readBlock(currPageNumber + \cf9 1\cf5 , fHandle, memPage);\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 readLastBlock\cf5  (SM_FileHandle *fHandle, SM_PageHandle memPage)\{\
	\cf8 // Re-directing (passing) to readBlock(...) function with pageNumber = totalNumPages i.e. last block\cf5 \
	\cf8 // printf("TOTAL PAGES = %d \\n", fHandle->totalNumPages);	\cf5 \
	
\f1\b \cf6 return
\f0\b0 \cf5  readBlock(fHandle->totalNumPages - \cf9 1\cf5 , fHandle, memPage);\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 writeBlock\cf5  (
\f1\b \cf6 int
\f0\b0 \cf5  pageNum, SM_FileHandle *fHandle, SM_PageHandle memPage) \{\
	\cf8 // Checking if the pageNumber parameter is less than Total number of pages and less than 0, then return respective error code\cf5 \
	
\f1\b \cf6 if
\f0\b0 \cf5  (pageNum < \cf9 0\cf5  || pageNum > fHandle->totalNumPages)\
        	
\f1\b \cf6 return
\f0\b0 \cf5  RC_WRITE_FAILED;\
	\
	\cf8 // Opening file stream in read & write mode. 'r+' mode opens the file for both reading and writing.	\cf5 \
	fileStream = fopen(fHandle->fileName, \cf4 "r+"\cf5 );\
	\
	\cf8 // Checking if file was successfully opened.\cf5 \
	
\f1\b \cf6 if
\f0\b0 \cf5 (fileStream == 
\f1\b \cf6 NULL
\f0\b0 \cf5 )\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_NOT_FOUND;\
\
	\cf8 // Setting the cursor(pointer) position of the file stream. The seek is successfull if fseek() return 0\cf5 \
	\
	
\f1\b \cf6 if
\f0\b0 \cf5 (fseek(fileStream, (pageNum * PAGE_SIZE), SEEK_SET) != \cf9 0\cf5 ) \{\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_WRITE_FAILED;	\
	\} \
	
\f1\b \cf6 else
\f0\b0 \cf5  \{\
		\cf8 // Writing content from memPage to fileStream stream\cf5 \
		fwrite(memPage, 
\f1\b \cf6 sizeof
\f0\b0 \cf5 (
\f1\b \cf6 char
\f0\b0 \cf5 ), strlen(memPage), fileStream);\
\
		\cf8 // Setting the current page position to the cursor(pointer) position of the file stream\cf5 \
		fHandle->curPagePos = ftell(fileStream);\
		\
\
		\cf8 // Closing file stream so that all the buffers are flushed.     	\cf5 \
		fclose(fileStream);\
		\
	\}	\
	\
	
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK;\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 writeCurrentBlock\cf5  (SM_FileHandle *fHandle, SM_PageHandle memPage) \{\
	\cf8 // Calculating current page number by dividing page size by current page position	\cf5 \
	
\f1\b \cf6 int
\f0\b0 \cf5  currPageNumber = fHandle->curPagePos / PAGE_SIZE;\
	\
	\cf8 // Incrementing total number of pages since we are adding this content to a new location as in current empty block.\cf5 \
	fHandle->totalNumPages++;\
	
\f1\b \cf6 return
\f0\b0 \cf5  writeBlock(currPageNumber, fHandle, memPage);\
\}\
\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 appendEmptyBlock\cf5  (SM_FileHandle *fHandle) \{\
	\cf8 // Creating an empty page of size PAGE_SIZE bytes\cf5 \
	SM_PageHandle emptyBlock = (SM_PageHandle)calloc(PAGE_SIZE, 
\f1\b \cf6 sizeof
\f0\b0 \cf5 (
\f1\b \cf6 char
\f0\b0 \cf5 ));\
	\
	\cf8 // Moving the cursor (pointer) position to the begining of the file stream.\cf5 \
	\cf8 // And the seek is success if fseek() return 0\cf5 \
\
	\
	
\f1\b \cf6 if
\f0\b0 \cf5 ( fseek(fileStream, \cf9 0\cf5 , SEEK_END) != \cf9 0\cf5  ) \{\
		free(emptyBlock);\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_WRITE_FAILED;\
		\
	\} \
	
\f1\b \cf6 if
\f0\b0 \cf5  (fwrite(emptyBlock, 
\f1\b \cf6 sizeof
\f0\b0 \cf5 (
\f1\b \cf6 char
\f0\b0 \cf5 ), PAGE_SIZE, fileStream) != PAGE_SIZE) \{\
        free(emptyBlock);\
        
\f1\b \cf6 return
\f0\b0 \cf5  RC_WRITE_FAILED; \cf8 // Return error: Failed to write an empty block.\cf5 \
    \}\
	\cf8 // De-allocating the memory previously allocated to 'emptyPageBuffer'.\cf5 \
	\cf8 // This is optional but always better to do for proper memory management.\cf5 \
	free(emptyBlock);\
	\
	\cf8 // Incrementing the total number of pages since we added an empty black.\cf5 \
	fHandle->totalNumPages++;\
	
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK;\
\}\
\

\f1\b \cf6 extern
\f0\b0 \cf5  RC \cf7 ensureCapacity\cf5  (
\f1\b \cf6 int
\f0\b0 \cf5  numberOfPages, SM_FileHandle *fHandle) \{\
	\cf8 // Opening file stream in append mode. 'a' mode opens the file to append the data at the end of file.\cf5 \
	
\f1\b \cf6 if
\f0\b0 \cf5 (fopen(fHandle->fileName, \cf4 "a"\cf5 ) == 
\f1\b \cf6 NULL
\f0\b0 \cf5 )\
		
\f1\b \cf6 return
\f0\b0 \cf5  RC_FILE_NOT_FOUND;\
	\
	\cf8 // Checking if numberOfPages is greater than totalNumPages.\cf5 \
	\cf8 // If that is the case, then add empty pages till numberofPages = totalNumPages\cf5 \
	
\f1\b \cf6 while
\f0\b0 \cf5 (numberOfPages > fHandle->totalNumPages)\
		appendEmptyBlock(fHandle);\
	\
	\cf8 // Closing file stream so that all the buffers are flushed. \cf5 \
	fclose(fileStream);\
	
\f1\b \cf6 return
\f0\b0 \cf5  RC_OK;\
\}\
}